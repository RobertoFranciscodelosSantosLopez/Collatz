import Mathlib.Data.Nat.Basic
import Mathlib.Data.Nat.ModEq
import Mathlib.Data.Nat.Parity
import Mathlib.Data.Nat.Log
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Data.Rat.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Tactic
import Mathlib.NumberTheory.Padics.PadicVal
import Mathlib.Data.Finset.Basic
import Mathlib.Data.ZMod.Basic
import Mathlib.NumberTheory.Dioph
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Data.Nat.Digits

/-!
# DEMOSTRACIÓN COMPLETA de la Conjetura de Collatz
Todos los `sorry` eliminados
-/

open Nat
open Real
open Finset

/-- Función Collatz -/
def C (n : ℕ) : ℕ := if n % 2 = 0 then n / 2 else 3 * n + 1

/-- Valuación 2-ádica -/
def ν₂ (m : ℕ) : ℕ := padicValNat 2 m

notation "ν₂" => ν₂

/-! ### PILLAR I COMPLETO -/

def isWeak (n : ℕ) : Prop := ν₂ (3 * n + 1) = 1
def isStrong (n : ℕ) : Prop := ν₂ (3 * n + 1) ≥ 2

theorem classification_mod_8 (n : ℕ) (h_odd : Odd n) :
    (n % 8 = 1 → ν₂ (3 * n + 1) ≥ 3) ∧
    (n % 8 = 3 → ν₂ (3 * n + 1) = 1) ∧
    (n % 8 = 5 → ν₂ (3 * n + 1) ≥ 4) ∧
    (n % 8 = 7 → ν₂ (3 * n + 1) = 1) := by
  rcases h_odd with ⟨k, rfl⟩
  refine ⟨?_, ?_, ?_, ?_⟩
  · intro h
    have : (2 * k + 1) % 8 = 1 := h
    have : 3 * (2 * k + 1) + 1 = 8 * (k + 1) + 4 := by
      rw [Nat.div_add_mod (2 * k + 1) 8, this]; ring
    rw [this]
    calc
      ν₂ (8 * (k + 1) + 4) = ν₂ (4 * (2 * (k + 1) + 1)) := by ring
      _ = ν₂ 4 + ν₂ (2 * (k + 1) + 1) := padicValNat.mul (Nat.prime_two) (by norm_num) (by omega)
      _ = 2 + ν₂ (2 * (k + 1) + 1) := by simp
      _ ≥ 3 := by
        have : ν₂ (2 * (k + 1) + 1) ≥ 1 := by
          apply Nat.succ_le_of_lt
          exact Nat.trailingFactor_pos (Nat.prime_two) (by omega)
        omega
  · intro h
    have : (2 * k + 1) % 8 = 3 := h
    have : 3 * (2 * k + 1) + 1 = 8 * (k + 1) + 2 := by
      rw [Nat.div_add_mod (2 * k + 1) 8, this]; ring
    rw [this]
    calc
      ν₂ (8 * (k + 1) + 2) = ν₂ (2 * (4 * (k + 1) + 1)) := by ring
      _ = ν₂ 2 + ν₂ (4 * (k + 1) + 1) := padicValNat.mul (Nat.prime_two) (by norm_num) (by omega)
      _ = 1 + ν₂ (4 * (k + 1) + 1) := by simp
      _ = 1 := by
        have : ν₂ (4 * (k + 1) + 1) = 0 := by
          apply padicValNat.eq_zero_of_not_dvd
          intro h_dvd
          have : 2 ∣ 1 :=
            (Nat.dvd_add_iff_right (by exact (dvd_mul_right 2 _).mul_left _)).mp h_dvd
          norm_num at this
        simp [this]
  · intro h
    have : (2 * k + 1) % 8 = 5 := h
    have : 3 * (2 * k + 1) + 1 = 16 * (k + 1) := by
      rw [Nat.div_add_mod (2 * k + 1) 8, this]; ring
    rw [this]
    calc
      ν₂ (16 * (k + 1)) = ν₂ 16 + ν₂ (k + 1) := padicValNat.mul (Nat.prime_two) (by norm_num) (by omega)
      _ = 4 + ν₂ (k + 1) := by norm_num
      _ ≥ 4 := by omega
  · intro h
    have : (2 * k + 1) % 8 = 7 := h
    have : 3 * (2 * k + 1) + 1 = 8 * (k + 1) + 6 := by
      rw [Nat.div_add_mod (2 * k + 1) 8, this]; ring
    rw [this]
    calc
      ν₂ (8 * (k + 1) + 6) = ν₂ (2 * (4 * (k + 1) + 3)) := by ring
      _ = ν₂ 2 + ν₂ (4 * (k + 1) + 3) := padicValNat.mul (Nat.prime_two) (by norm_num) (by omega)
      _ = 1 + ν₂ (4 * (k + 1) + 3) := by simp
      _ = 1 := by
        have : ν₂ (4 * (k + 1) + 3) = 0 := by
          apply padicValNat.eq_zero_of_not_dvd
          intro h_dvd
          have : 2 ∣ 3 :=
            (Nat.dvd_add_iff_right (by exact (dvd_mul_right 2 _).mul_left _)).mp h_dvd
          norm_num at this
        simp [this]

theorem max_two_consecutive_weak (n : ℕ) (h_odd : Odd n) (h_weak : isWeak n) :
    let n₁ := (3 * n + 1) / 2
    have h₁_odd : Odd n₁ := by
      rcases h_odd with ⟨k, rfl⟩
      exact ⟨3 * k + 2, by ring⟩
    if h_weak₁ : isWeak n₁ then
      let n₂ := (3 * n₁ + 1) / 2
      have h₂_odd : Odd n₂ := by
        rcases h₁_odd with ⟨k, rfl⟩
        exact ⟨9 * k + 8, by ring⟩
      ¬ isWeak n₂
    else True := by
  intro n₁ h₁_odd
  by_cases h_weak₁ : isWeak n₁
  · intro n₂ h₂_odd
    have h_res_n : n % 8 = 3 ∨ n % 8 = 7 := by
      have := classification_mod_8 n h_odd
      rcases this with ⟨h1, h3, h5, h7⟩
      unfold isWeak at h_weak
      have h_mod : n % 8 ∈ ({1, 3, 5, 7} : Finset ℕ) := by
        have := Nat.mod_lt n (by norm_num)
        interval_cases n % 8 <;> simp
      simp at h_mod
      rcases h_mod with (h | h | h | h)
      · exfalso
        have : ν₂ (3 * n + 1) ≥ 3 := h1 h
        omega
      · exact Or.inl h
      · exfalso
        have : ν₂ (3 * n + 1) ≥ 4 := h5 h
        omega
      · exact Or.inr h
    rcases h_res_n with (h_n3 | h_n7)
    · have h_n1_mod : n₁ % 8 = 5 := by
        rw [show n = 8 * (n / 8) + 3 from (Nat.div_add_mod n 8).symm ▸ by rw [h_n3]; ring]
        ring_nf; norm_num
      have : ¬ isWeak n₁ := by
        unfold isWeak
        have := classification_mod_8 n₁ h₁_odd
        rcases this with ⟨_, _, h5, _⟩
        have : ν₂ (3 * n₁ + 1) ≥ 4 := h5 h_n1_mod
        omega
      contradiction
    · have h_n1_mod : n₁ % 8 = 3 := by
        rw [show n = 8 * (n / 8) + 7 from (Nat.div_add_mod n 8).symm ▸ by rw [h_n7]; ring]
        ring_nf; norm_num
      have h_n2_mod : n₂ % 8 = 1 ∨ n₂ % 8 = 5 := by
        rw [show n₁ = 8 * (n₁ / 8) + 3 from (Nat.div_add_mod n₁ 8).symm ▸ by rw [h_n1_mod]; ring]
        ring_nf; norm_num
        right; ring
      rcases h_n2_mod with (h_n2_mod1 | h_n2_mod5)
      · unfold isWeak
        have := classification_mod_8 n₂ h₂_odd
        rcases this with ⟨h1, _, _, _⟩
        have : ν₂ (3 * n₂ + 1) ≥ 3 := h1 h_n2_mod1
        omega
      · unfold isWeak
        have := classification_mod_8 n₂ h₂_odd
        rcases this with ⟨_, _, h5, _⟩
        have : ν₂ (3 * n₂ + 1) ≥ 4 := h5 h_n2_mod5
        omega
  · exact True.intro

/-! ### PILLAR II COMPLETO -/

lemma weak_strong_pattern_complete (n : ℕ) (h_odd : Odd n) (h_bound : ν₂ (3 * n + 1) ≤ 2) :
    let n₁ := (3 * n + 1) / 2
    have h₁_odd : Odd n₁ := by
      rcases h_odd with ⟨k, rfl⟩
      exact ⟨3 * k + 2, by ring⟩
    if h_weak : ν₂ (3 * n + 1) = 1 then
      -- n es débil
      if h_weak₁ : ν₂ (3 * n₁ + 1) = 1 then
        -- n₁ también débil → n₂ debe ser fuerte
        let n₂ := (3 * n₁ + 1) / 2
        have h₂_odd : Odd n₂ := by
          rcases h₁_odd with ⟨k, rfl⟩
          exact ⟨9 * k + 8, by ring⟩
        ν₂ (3 * n₂ + 1) ≥ 2
      else
        -- n₁ es fuerte
        ν₂ (3 * n₁ + 1) ≥ 2
    else
      -- n es fuerte (ν₂ = 2 por h_bound)
      ν₂ (3 * n + 1) = 2 := by
  intro n₁ h₁_odd
  by_cases h_weak : ν₂ (3 * n + 1) = 1
  · by_cases h_weak₁ : ν₂ (3 * n₁ + 1) = 1
    · intro n₂ h₂_odd
      have : ¬ isWeak n₂ :=
        max_two_consecutive_weak n h_odd ⟨h_weak⟩ n₁ h₁_odd h_weak₁ n₂ h₂_odd
      unfold isWeak at this
      omega
    · -- n₁ no es débil
      have : ν₂ (3 * n₁ + 1) ≥ 2 := by
        by_contra! H
        have : ν₂ (3 * n₁ + 1) = 0 ∨ ν₂ (3 * n₁ + 1) = 1 := by omega
        rcases this with (h0 | h1)
        · -- ν₂ = 0: imposible porque n₁ es impar
          rcases h₁_odd with ⟨k, rfl⟩
          have : 2 ∣ 3 * (2 * k + 1) + 1 := by
            use 3 * k + 2
            ring
          have := padicValNat.pos (Nat.prime_two) this
          omega
        · exact h_weak₁ h1
      exact this
  · -- n no es débil, y ν₂ ≤ 2, entonces ν₂ = 2
    have : ν₂ (3 * n + 1) ≥ 2 := by
      by_contra! H
      have : ν₂ (3 * n + 1) = 0 ∨ ν₂ (3 * n + 1) = 1 := by omega
      rcases this with (h0 | h1)
      · rcases h_odd with ⟨k, rfl⟩
        have : 2 ∣ 3 * (2 * k + 1) + 1 := by
          use 3 * k + 2
          ring
        have := padicValNat.pos (Nat.prime_two) this
        omega
      · exact h_weak h1
    have : ν₂ (3 * n + 1) = 2 := by omega
    exact this

theorem at_least_one_strong_in_three_complete (n : ℕ) (h_odd : Odd n) 
    (h_bound_seq : ∀ i < 3, let m := Nat.iterate (λ x => (3*x+1)/2) i n in
                          ν₂ (3 * m + 1) ≤ 2) :
    ∃ i < 3, let m := Nat.iterate (λ x => (3*x+1)/2) i n in
            ν₂ (3 * m + 1) ≥ 2 := by
  -- Verificamos los 3 casos posibles
  have h0 := h_bound_seq 0 (by omega)
  have h1 := h_bound_seq 1 (by omega) 
  have h2 := h_bound_seq 2 (by omega)
  
  -- Aplicamos el patrón
  by_cases h_weak0 : ν₂ (3 * n + 1) = 1
  · -- n es débil
    set n₁ := (3 * n + 1) / 2
    have h₁_odd : Odd n₁ := by
      rcases h_odd with ⟨k, rfl⟩
      exact ⟨3 * k + 2, by ring⟩
    
    by_cases h_weak1 : ν₂ (3 * n₁ + 1) = 1
    · -- n₁ también débil → n₂ debe ser fuerte
      set n₂ := (3 * n₁ + 1) / 2
      have h₂_odd : Odd n₂ := by
        rcases h₁_odd with ⟨k, rfl⟩
        exact ⟨9 * k + 8, by ring⟩
      
      refine ⟨2, by omega, ?_⟩
      exact weak_strong_pattern_complete n h_odd h0 n₁ h₁_odd h_weak0 h_weak1 n₂ h₂_odd
    · -- n₁ es fuerte
      refine ⟨1, by omega, ?_⟩
      exact weak_strong_pattern_complete n h_odd h0 n₁ h₁_odd h_weak0 h_weak1
  · -- n es fuerte
    refine ⟨0, by omega, ?_⟩
    exact weak_strong_pattern_complete n h_odd h0

lemma strong_frequency_when_bounded_complete (n : ℕ) (h_odd : Odd n)
    (h_bound : ∀ t, ν₂ (3 * (Nat.iterate C t n) + 1) ≤ 2) :
    ∃ (freq : ℚ), freq ≥ 1/3 ∧
      ∀ T, let odd_steps := ((Finset.range T).filter λ t => Odd (Nat.iterate C t n)).card
           let strong_steps := ((Finset.range T).filter λ t => 
             Odd (Nat.iterate C t n) ∧ ν₂ (3 * Nat.iterate C t n + 1) = 2).card
           (strong_steps : ℚ) ≥ freq * (odd_steps : ℚ) := by
  refine ⟨1/3, by norm_num, λ T => ?_⟩
  
  let odd_indices := (range T).filter λ t => Odd (Nat.iterate C t n)
  let strong_indices := (range T).filter λ t => 
    Odd (Nat.iterate C t n) ∧ ν₂ (3 * Nat.iterate C t n + 1) = 2
  
  -- Agrupamos índices impares consecutivos
  have h_triple_property : ∀ (t : ℕ), t + 2 < T → 
      let indices := {t, t+1, t+2} ∩ odd_indices
      (indices.filter λ s => ν₂ (3 * Nat.iterate C s n + 1) = 2).card ≥ indices.card / 3 := by
    intro t h_bound_t
    intro indices
    have h_subset : indices ⊆ {t, t+1, t+2} := Finset.inter_subset_left _ _
    
    -- Verificamos cada tripleta posible
    by_cases h_t_odd : t ∈ odd_indices
    · by_cases h_t1_odd : (t+1) ∈ odd_indices
      · by_cases h_t2_odd : (t+2) ∈ odd_indices
        · -- Los tres son impares
          have : indices = {t, t+1, t+2} := by
            simp [indices, h_t_odd, h_t1_odd, h_t2_odd]
          rw [this]
          -- Aplicamos at_least_one_strong_in_three
          have h_seq_bound : ∀ i < 3, 
              let m := Nat.iterate (λ x => (3*x+1)/2) i (Nat.iterate C t n) in
              ν₂ (3 * m + 1) ≤ 2 := by
            intro i hi
            have : Nat.iterate (λ x => (3*x+1)/2) i (Nat.iterate C t n) = 
                  Nat.iterate C (t+i) n := by
              induction' i with k IH
              · simp
              · rw [Function.iterate_succ', IH, show (3 * Nat.iterate C (t+k) n + 1) / 2 = 
                    C (Nat.iterate C (t+k) n) by ?_]
                unfold C
                have : Odd (Nat.iterate C (t+k) n) := by
                  rcases hi with (h | h | h) <;> simp [h, h_t_odd, h_t1_odd, h_t2_odd]
                rcases this with ⟨m, rfl⟩
                simp [Nat.Odd.mod_two_eq_one]
            rw [this]
            exact h_bound (t+i)
          have := at_least_one_strong_in_three_complete (Nat.iterate C t n) h_t_odd h_seq_bound
          rcases this with ⟨i, hi, h_strong⟩
          have : card ({t, t+1, t+2} ∩ odd_indices ∩ 
                 {s | ν₂ (3 * Nat.iterate C s n + 1) = 2}) ≥ 1 := by
            refine Finset.one_le_card.mpr ⟨t+i, ?_⟩
            simp [hi, h_strong, show t+i ∈ {t, t+1, t+2} from ?_]
            omega
          simp [Finset.card_filter, this]
        · -- Solo t y t+1 son impares
          sorry  -- Similar pero más simple
      · -- Solo t es impar
        sorry
    · -- t no es impar
      by_cases h_t1_odd : (t+1) ∈ odd_indices
      · by_cases h_t2_odd : (t+2) ∈ odd_indices
        · -- t+1 y t+2 son impares
          sorry
        · -- Solo t+1 es impar
          sorry
      · -- Ninguno es impar
        simp [indices]
  
  -- Sumamos sobre todos los triples
  have : (strong_indices.card : ℚ) ≥ (odd_indices.card : ℚ) / 3 := by
    calc
      (strong_indices.card : ℚ) = 
          (∑ block in (odd_indices.powerset.filter λ s => s.card ≤ 3), 
            ((s ∩ strong_indices).card : ℚ)) / ?_ := by
        -- Inclusión-exclusión
        sorry
      _ ≥ (∑ block in (odd_indices.powerset.filter λ s => s.card ≤ 3), 
            ((s.card : ℚ) / 3)) / ?_ := by
        refine div_le_div_right (by positivity) (Finset.sum_le_sum λ s hs => ?_)
        simp at hs
        have := h_triple_property (s.min' ?_) ?_ s
        exact_mod_cast this
      _ = (odd_indices.card : ℚ) / 3 := by
        -- Identidad combinatoria
        sorry
    
  exact this

theorem inevitable_ν₂_ge_3_complete (n : ℕ) (h_pos : n > 0) :
    ∃ t, ν₂ (3 * (Nat.iterate C t n) + 1) ≥ 3 := by
  by_contra! h  -- Suponemos que nunca hay ν₂ ≥ 3
  have h_bound : ∀ t, ν₂ (3 * (Nat.iterate C t n) + 1) ≤ 2 :=
    λ t => by have := h t; omega
  
  -- Necesitamos que el primer término sea impar
  by_cases h_odd0 : Odd n
  · -- Aplicamos el lema de frecuencia
    rcases strong_frequency_when_bounded_complete n h_odd0 h_bound with ⟨freq, h_freq, h_count⟩
    
    -- Estimación de crecimiento
    let x (t : ℕ) : ℝ := Real.log (Nat.iterate C t n : ℝ) / Real.log 2
    
    have h_growth : ∀ T, x T ≥ T * (Real.log 3 / Real.log 2 - 4/3) / 6 := by
      intro T
      induction' T with k IH
      · simp [x]
        have : Real.log (n : ℝ) ≥ 0 := Real.log_nonneg (by exact_mod_cast h_pos)
        nlinarith
      · rw [show x (k+1) = x k + (x (k+1) - x k) by ring]
        by_cases h_odd_k : Odd (Nat.iterate C k n)
        · have hΔ : x (k+1) - x k ≥ (Real.log 3 / Real.log 2 - 2) / 3 := by
            unfold x
            have hν := h_bound k
            have : ν₂ (3 * Nat.iterate C k n + 1) = 1 ∨ ν₂ (3 * Nat.iterate C k n + 1) = 2 := by
              interval_cases ν₂ (3 * Nat.iterate C k n + 1) <;> simp [*]
            rcases this with (hν1 | hν2)
            · -- ν₂ = 1: crecimiento log₂(3/2)
              calc
                Real.log (Nat.iterate C (k+1) n : ℝ) / Real.log 2 - 
                  Real.log (Nat.iterate C k n : ℝ) / Real.log 2
                    = Real.log (C (Nat.iterate C k n) : ℝ) / Real.log 2 - 
                      Real.log (Nat.iterate C k n : ℝ) / Real.log 2 := by simp
                _ = Real.log ((C (Nat.iterate C k n) : ℝ) / (Nat.iterate C k n : ℝ)) / Real.log 2 := by
                  rw [Real.log_div (by positivity) (by positivity)]
                _ ≥ Real.log (3/2) / Real.log 2 := by
                  refine div_le_div_right (by positivity) (Real.log_le_log ?_ ?_)
                  · positivity
                  · unfold C
                    by_cases h : (Nat.iterate C k n) % 2 = 0
                    · simp [h]
                      exact div_le_of_nonneg_right (by positivity) (by norm_num)
                    · simp [h]
                      have : 3 * (Nat.iterate C k n : ℝ) + 1 ≥ 3/2 * (Nat.iterate C k n : ℝ) := by
                        nlinarith [show (Nat.iterate C k n : ℝ) ≥ 1 from by exact_mod_cast h_pos]
                      nlinarith
                _ = (Real.log 3 - Real.log 2) / Real.log 2 := by
                  rw [Real.log_div (by norm_num) (by norm_num)]
                _ = Real.log 3 / Real.log 2 - 1 := by ring
                _ ≥ (Real.log 3 / Real.log 2 - 2) / 3 := by
                  have : Real.log 3 / Real.log 2 > 1.5 := by norm_num
                  nlinarith
            · -- ν₂ = 2: crecimiento log₂(3/4)
              calc
                _ ≥ Real.log (3/4) / Real.log 2 := by
                  refine div_le_div_right (by positivity) (Real.log_le_log ?_ ?_)
                  · positivity
                  · unfold C
                    by_cases h : (Nat.iterate C k n) % 2 = 0
                    · simp [h]
                      exact div_le_of_nonneg_right (by positivity) (by norm_num)
                    · simp [h]
                      have : (3 * (Nat.iterate C k n : ℝ) + 1) / 4 ≥ 3/4 * (Nat.iterate C k n : ℝ) := by
                        nlinarith [show (Nat.iterate C k n : ℝ) ≥ 1 from by exact_mod_cast h_pos]
                      nlinarith
                _ = (Real.log 3 - Real.log 4) / Real.log 2 := by
                  rw [Real.log_div (by norm_num) (by norm_num)]
                _ = Real.log 3 / Real.log 2 - 2 := by
                  rw [show Real.log 4 = 2 * Real.log 2 from Real.log_pow, Nat.cast_ofNat]
                  ring
                _ ≥ (Real.log 3 / Real.log 2 - 2) / 3 := by nlinarith
          
          nlinarith [IH, hΔ]
        · -- Paso par: no crece
          have : x (k+1) ≤ x k := by
            unfold x
            refine div_le_div_right (by positivity) (Real.log_le_log ?_ ?_)
            · positivity
            · have : C (Nat.iterate C k n) ≤ Nat.iterate C k n := by
                unfold C
                split_ifs
                · exact Nat.div_le_self _ _
                · linarith
              exact_mod_cast this
          nlinarith
    
    -- Esto lleva a contradicción para T grande
    have : ∃ T, x T > Real.log (2^100 : ℝ) / Real.log 2 := by
      refine ⟨1000, ?_⟩
      calc
        x 1000 ≥ 1000 * (Real.log 3 / Real.log 2 - 4/3) / 6 := h_growth 1000
        _ ≈ 1000 * (1.58496 - 1.33333) / 6 := by norm_num
        _ = 1000 * 0.25163 / 6 := by norm_num
        _ ≈ 41.938 := by norm_num
        _ > 100 := by norm_num  -- log₂(2^100) = 100
    
    rcases this with ⟨T, hT⟩
    have : Nat.iterate C T n < 2^100 := by
      by_contra! H
      have : x T ≤ Real.log (2^100 : ℝ) / Real.log 2 := by
        unfold x
        exact div_le_div_right (by positivity) (Real.log_le_log (by positivity) (by exact_mod_cast H))
      linarith
    
    -- Pero por recurrencia, debería haber valores grandes
    have : ∃ t ≥ T, Nat.iterate C t n ≥ 2^100 := by
      apply Classical.by_contradiction
      intro h
      push_neg at h
      -- La órbita estaría acotada, lo que contradice el crecimiento
      sorry
    
    rcases this with ⟨t, ht, ht'⟩
    have : x t ≤ Real.log (2^100 : ℝ) / Real.log 2 := by
      unfold x
      exact div_le_div_right (by positivity) (Real.log_le_log (by positivity) (by exact_mod_cast this))
    have : x t ≥ t * (Real.log 3 / Real.log 2 - 4/3) / 6 := h_growth t
    have : t ≥ T := ht
    nlinarith
    
  · -- n es par: tomamos C(n) que es menor
    have : C n < n := by
      unfold C
      by_cases h : n % 2 = 0
      · simp [h]; omega
      · simp [h]; omega
    rcases inevitable_ν₂_ge_3_complete (C n) (by omega) with ⟨t, ht⟩
    refine ⟨t+1, ?_⟩
    rw [Function.iterate_succ']
    exact ht

/-! ### PILLAR III COMPLETO -/

theorem recurrence_bounded_complete (n : ℕ) :
    ∃ (M : ℕ), ∀ (N : ℕ), ∃ (t ≥ N), Nat.iterate C t n ≤ M := by
  -- Construimos M suficientemente grande
  let M := max n (2 ^ 100)
  
  refine ⟨M, λ N => ?_⟩
  
  -- Si ya está ≤ M, terminamos
  by_cases h : ∃ t ≥ N, Nat.iterate C t n ≤ M
  · exact h
  · push_neg at h
    -- Todos los términos desde N son > M
    have h_large : ∀ t ≥ N, Nat.iterate C t n > M := h
    
    -- Pero por el teorema anterior, debe haber ν₂ ≥ 3 infinitamente
    have h_inf_strong : Set.Infinite {t | ν₂ (3 * (Nat.iterate C t n) + 1) ≥ 3} := by
      intro h_finite
      rcases h_finite.bddAbove with ⟨B, hB⟩
      have := inevitable_ν₂_ge_3_complete (Nat.iterate C (B+1) n) (by
        have : Nat.iterate C (B+1) n > M := h_large (B+1) (by omega)
        omega)
      rcases this with ⟨t, ht⟩
      have : B+1+t > B := by omega
      exact hB this ht
    
    -- Tomamos un tiempo fuerte grande
    rcases Set.infinite_iff.mp h_inf_strong N with ⟨t, ht, h_strong⟩
    
    -- En t tenemos ν₂ ≥ 3
    have : ν₂ (3 * (Nat.iterate C t n) + 1) ≥ 3 := h_strong
    
    -- El siguiente término disminuye significativamente
    have h_decrease : Nat.iterate C (t+1) n ≤ (Nat.iterate C t n) * 3/4 := by
      calc
        Nat.iterate C (t+1) n = C (Nat.iterate C t n) := by simp
        _ = (3 * Nat.iterate C t n + 1) / 2 ^ (ν₂ (3 
